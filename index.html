<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sand Dissolve Slideshow</title>

  <!-- Manrope ExtraLight -->
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200;400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg-color:#0b0c10;

      /* Slideshow */
      --slide-duration: 6s;
      --transition-duration: 1.6s;
      --noise-scale: 2.2;
      --edge-softness: 0.18;
      --drift-speed: 0.06;

      /* Widget sizing/scale */
      --widget-width: 180px;
      --widget-scale: 1;
    }

    html, body {
      height:100%; margin:0; background:var(--bg-color);
      font-family:'Manrope',sans-serif; font-weight:200;
      overflow:hidden; color:#eef1f5;
    }

    .stage { position:fixed; inset:0; overflow:hidden; background:var(--bg-color); }

    /* Center the canvas; JS sets pixel size to preserve aspect (no distortion) */
    canvas{
      position:absolute;
      top:50%; left:50%;
      transform: translate(-50%, -50%);
      width:auto; height:auto;
      display:block; z-index:0;
    }

    .vignette::after{ content:""; position:absolute; inset:0; pointer-events:none;
      background: radial-gradient(120% 120% at 50% 60%, transparent 45%, rgba(0,0,0,0.28) 100%);
      mix-blend-mode:multiply; }

    .badge{ position:absolute; right:24px; bottom:20px; color:#fff; opacity:.0; font:200 14px 'Manrope',sans-serif; }

    @media (prefers-reduced-motion: reduce){ :root{ --transition-duration: 0s; } }

    /* === Widgets column (LEFT) === */
    .widgets-left{
      position: fixed; top:16px; left:16px; z-index:1000; pointer-events:auto;
      display:flex; flex-direction:column; gap:14px; align-items:flex-start;
    }

    /* Card base */
    .card{
      width: var(--widget-width);
      transform: scale(var(--widget-scale));
      transform-origin: top left;

      border-radius: 22px;
      padding: 10px;
      background: rgba(18, 20, 24, 0.45);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 8px 28px rgba(0,0,0,0.25);
      font-weight: 200;
      color: #eef1f5;
    }

    .card-header{
      display:flex; justify-content:space-between; align-items:center;
      padding: 8px 12px;
      margin: -2px -2px 10px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 16px;
      font-size: 13px; letter-spacing:.3px;
    }

    /* ===== Weather card ===== */
    #weatherCard .weather-row{
      display:flex; flex-direction:column; gap:6px; align-items:flex-start;
      padding: 10px 12px 12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 16px;
      margin-bottom: 10px;
    }
    #weatherCard .weather-icon{
      font-size: 24px; line-height:1;
      filter: grayscale(1) contrast(1.05) brightness(1.05);
      width: 100%;
      text-align: center;
      align-self: center;
      margin-top: 2px;
    }
    #weatherCard .weather-temp{ font-size: 42px; line-height:1; font-weight:200; margin-top: 2px; }
    #weatherCard .weather-desc{ font-size: 13px; opacity:.92; }

    #weatherCard .weather-forecast{ display: grid; grid-template-columns: 1fr; gap: 8px; }
    #weatherCard .forecast-item{
      display:grid;
      grid-template-columns: 1fr 40px 48px;  /* time | icon | temp */
      align-items:center;
      padding: 8px 10px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
    }
    #weatherCard .forecast-time{ font-size: 12px; opacity:.9; }
    #weatherCard .wx{
      display:flex; align-items:center; justify-content:center;
      width:40px; height:20px; margin:0 auto;
      filter: grayscale(1) contrast(1.05) brightness(1.05);
      text-align:center;
    }
    #weatherCard .forecast-temp{
      justify-self:end;
      font-size: 13px; padding: 6px 8px; min-width: 42px; text-align:center;
      background: rgba(0,0,0,0.25); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; opacity:.95;
    }

    /* ===== AQI card ===== */
    #aqiCard .aqi-body{
      display:flex; flex-direction:column; gap:8px; align-items:center;
      padding: 12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255, 255, 255, 0.02));
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 16px;
    }
    #aqiValue{ font-size:40px; line-height:1; }
    #aqiCat{ font-size:13px; opacity:.92; }
    #aqiBadge{
      font-size:12px; padding:4px 8px; border-radius:10px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      line-height:1;
    }
    .aqi-bar{
      width:100%; height:6px; border-radius:4px;
      background: linear-gradient(90deg,#2ecc71,#f1c40f,#e67e22,#e74c3c,#9b59b6,#7f1d1d);
      opacity:.75;
      position: relative; overflow:hidden;
    }
    .aqi-pointer{
      position:absolute; top:-3px; width:2px; height:12px; background:#fff; border-radius:1px; opacity:.9;
      left:0%;
    }
    .aqi-metrics{
      margin-top:6px;
      display:flex; gap:8px;
    }
    .pill{
      font-size:11px; padding:6px 8px; border-radius:10px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
    }
    .pill strong{ font-weight:400; margin-left:6px; }
  </style>
</head>
<body>
  <div class="stage vignette">
    <canvas id="glcanvas"></canvas>
    <div class="badge" id="badge"></div>

    <!-- LEFT widgets column -->
    <div class="widgets-left">

      <!-- Weather -->
      <div class="card" id="weatherCard">
        <div class="card-header">
          <span>Weather</span>
          <span id="weatherCity">‚Äî</span>
        </div>
        <div class="weather-row">
          <div class="weather-icon" id="weatherIcon" aria-hidden="true">‚òÅÔ∏è</div>
          <div class="weather-main">
            <div class="weather-temp" id="weatherTemp">--¬∞</div>
            <div class="weather-desc" id="weatherDesc">Loading‚Ä¶</div>
          </div>
        </div>
        <div class="weather-forecast" id="weatherForecast"></div>
      </div>

      <!-- AQI -->
      <div class="card" id="aqiCard">
        <div class="card-header">
          <span>Air Quality</span>
          <span id="aqiCity">‚Äî</span>
        </div>
        <div class="aqi-body">
          <div id="aqiBadge">AQI ‚Äî</div>
          <div id="aqiValue">--</div>
          <div id="aqiCat">Loading‚Ä¶</div>
          <div class="aqi-bar">
            <div class="aqi-pointer" id="aqiPointer"></div>
          </div>
          <div class="aqi-metrics">
            <div class="pill">PM2.5<strong id="pm25">‚Äî</strong></div>
            <div class="pill">PM10<strong id="pm10">‚Äî</strong></div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <script>
  // ========= Config =========
  const CITY_NAME = "Sultanpur, Delhi, India";
  const COUNTRY_CODE = "IN";

  // Fallback coordinates ‚Äî Sultanpur (Delhi area)
  const FALLBACK_COORDS = {
    latitude: 28.4959,
    longitude: 77.1500,
    label: "Sultanpur, India"
  };

  // Slides (PNG supported)
  const IMAGES = [
    "images/slide1.png",
    "images/slide2.png",
    "images/slide3.png",
    "images/slide4.png",
    "images/slide5.png",
  ];

  // CSS var readers
  function cssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  function readSeconds(name, fallback){
    const v = cssVar(name); const n = parseFloat((v||'').replace('s',''));
    return isFinite(n)?n*1000:fallback*1000;
  }

  const SLIDE_MS      = readSeconds('--slide-duration', 6);
  const TRANSITION_MS = readSeconds('--transition-duration', 1.6);
  const NOISE_SCALE   = parseFloat(cssVar('--noise-scale')) || 2.2;
  const EDGE_SOFT     = parseFloat(cssVar('--edge-softness')) || 0.18;
  const DRIFT_SPEED   = parseFloat(cssVar('--drift-speed')) || 0.06;

  // ========= WebGL2 setup (4K buffer + letterboxed sizing) =========
  const canvas = document.getElementById('glcanvas');
  const gl = canvas.getContext('webgl2', { premultipliedAlpha: true, antialias: true });
  if(!gl){ alert('WebGL2 not available'); }

  const FORCE_NATIVE_4K = true;
  const NATIVE_SIZE = [4096, 2160]; // your panel resolution

  function sizeGLBuffer(){
    canvas.width  = NATIVE_SIZE[0];
    canvas.height = NATIVE_SIZE[1];
    gl.viewport(0, 0, canvas.width, canvas.height);
  }

  function fitCanvasToViewport(){
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const aspect = canvas.width / canvas.height;

    let dispW, dispH;
    if (vw / vh > aspect) { // viewport wider -> fit height
      dispH = vh;
      dispW = Math.round(vh * aspect);
    } else {                // viewport taller -> fit width
      dispW = vw;
      dispH = Math.round(vw / aspect);
    }
    canvas.style.width  = dispW + 'px';
    canvas.style.height = dispH + 'px';
  }

  function resize(){
    if (FORCE_NATIVE_4K) {
      sizeGLBuffer();
      fitCanvasToViewport();
    } else {
      const dpr = window.devicePixelRatio || 1;
      const w = Math.floor(window.innerWidth  * dpr);
      const h = Math.floor(window.innerHeight * dpr);
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w; canvas.height = h;
      }
      gl.viewport(0,0,canvas.width,canvas.height);
      canvas.style.width  = '100vw';
      canvas.style.height = '100vh';
    }
  }

  resize();
  window.addEventListener('resize', fitCanvasToViewport);

  // ===== Shaders =====
  const vs = `#version 300 es
  precision highp float;
  const vec2 POS[4] = vec2[4](vec2(-1.,-1.), vec2(1.,-1.), vec2(-1.,1.), vec2(1.,1.));
  out vec2 vUv;
  void main(){ vec2 p = POS[gl_VertexID]; vUv = p*0.5+0.5; gl_Position = vec4(p,0.,1.); }`;

  const fs = `#version 300 es
  precision highp float;
  in vec2 vUv; out vec4 frag;
  uniform sampler2D uTex0, uTex1; uniform vec2 uResolution;
  uniform float uProgress, uTime, uNoiseScale, uEdgeSoft, uDrift;
  float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453123); }
  float noise(vec2 p){ vec2 i=floor(p), f=fract(p); float a=hash(i), b=hash(i+vec2(1,0)), c=hash(i+vec2(0,1)), d=hash(i+vec2(1,1)); vec2 u=f*f*(3.-2.*f); return mix(mix(a,b,u.x), mix(c,d,u.x), u.y); }
  float fbm(vec2 p){ float v=0., a=.5; mat2 m=mat2(1.6,1.2,-1.2,1.6); for(int i=0;i<5;i++){ v+=a*noise(p); p=m*p; a*=.5; } return v; }
  vec2 coverUv(vec2 uv, vec2 texSize, vec2 res){ float rTex=texSize.x/texSize.y, rCan=res.x/res.y;
    if(rTex>rCan){ float s=rTex/rCan; uv.y=(uv.y-.5)*s+.5; } else { float s=rCan/rTex; uv.x=(uv.x-.5)*s+.5; } return uv; }
  void main(){
    vec2 res=uResolution; vec2 drift=vec2(uTime*uDrift, uTime*uDrift*.6);
    float n=fbm((vUv*res/uNoiseScale)+drift);
    float mask=(uProgress<=0.)?0.:1.-smoothstep(uProgress-uEdgeSoft, uProgress+uEdgeSoft, n);
    float d=hash(vUv*res+uTime*10.)*.015; mask=clamp(mask+d,0.,1.);
    vec2 s0=vec2(textureSize(uTex0,0)), s1=vec2(textureSize(uTex1,0));
    vec4 c0=texture(uTex0, coverUv(vUv,s0,res));
    vec4 c1=texture(uTex1, coverUv(vUv,s1,res));
    frag=mix(c0,c1,mask);
  }`;

  function compile(type, src){
    const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPLETE_STATUS) && !gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      throw new Error(gl.getShaderInfoLog(s));
    }
    return s;
  }
  function program(vsSrc, fsSrc){
    const p=gl.createProgram();
    gl.attachShader(p, compile(gl.VERTEX_SHADER,vsSrc));
    gl.attachShader(p, compile(gl.FRAGMENT_SHADER,fsSrc));
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p));
    return p;
  }

  const prog = program(vs, fs); gl.useProgram(prog);
  const loc = {
    uTex0: gl.getUniformLocation(prog, 'uTex0'),
    uTex1: gl.getUniformLocation(prog, 'uTex1'),
    uResolution: gl.getUniformLocation(prog, 'uResolution'),
    uProgress: gl.getUniformLocation(prog, 'uProgress'),
    uTime: gl.getUniformLocation(prog, 'uTime'),
    uNoiseScale: gl.getUniformLocation(prog, 'uNoiseScale'),
    uEdgeSoft: gl.getUniformLocation(prog, 'uEdgeSoft'),
    uDrift: gl.getUniformLocation(prog, 'uDrift'),
  };
  const vao = gl.createVertexArray(); gl.bindVertexArray(vao);

  // Textures
  function createTexture(img){
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
    return tex;
  }
  async function loadImage(src){ return new Promise((res, rej)=>{ const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>res(i); i.onerror=rej; i.src=src; }); }

  let images=[], textures=[];
  (async()=>{ images = await Promise.all(IMAGES.map(loadImage)); textures = images.map(createTexture); start(); })().catch(console.error);

  // Slideshow engine
  let currentIndex = 0, nextIndex = (currentIndex + 1) % IMAGES.length;
  let phase = 'dwell', phaseEnd = performance.now();

  function bindTextures(i0, i1){
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, textures[i0]); gl.uniform1i(loc.uTex0, 0);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, textures[i1]); gl.uniform1i(loc.uTex1, 1);
  }

  function start(){
    bindTextures(currentIndex, nextIndex);
    phase = 'dwell'; phaseEnd = performance.now() + SLIDE_MS;
    gl.uniform1f(loc.uProgress, 0.0);
    requestAnimationFrame(loop);

    initWeatherAndAQI();
  }

  function loop(now){
    const res = [canvas.width, canvas.height];
    if(now >= phaseEnd){
      if(phase === 'dwell'){ phase='transition'; phaseEnd=now+TRANSITION_MS; bindTextures(currentIndex,nextIndex); }
      else{ currentIndex=nextIndex; nextIndex=(currentIndex+1)%IMAGES.length; bindTextures(currentIndex,nextIndex); phase='dwell'; phaseEnd=now+SLIDE_MS; gl.uniform1f(loc.uProgress,0.0); }
    }
    gl.uniform2f(loc.uResolution, res[0], res[1]);
    gl.uniform1f(loc.uTime, now*0.001);
    gl.uniform1f(loc.uNoiseScale, NOISE_SCALE * 200.0);
    gl.uniform1f(loc.uEdgeSoft, EDGE_SOFT);
    gl.uniform1f(loc.uDrift, DRIFT_SPEED);

    if(phase === 'transition'){
      const dur = Math.max(1.0, TRANSITION_MS);
      const t = 1.0 - Math.max(0.0, (phaseEnd - now) / dur);
      const eased = 1.0 - Math.pow(1.0 - t, 3.0);
      gl.uniform1f(loc.uProgress, eased);
    } else {
      gl.uniform1f(loc.uProgress, 0.0);
    }

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(loop);
  }

  // ===== Weather + location resolve =====
  async function resolveLocation(q, countryCode=""){
    const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(q)}&count=10&language=en&format=json`;
    const geo = await fetch(url).then(r=>r.json());

    if (geo && geo.results && geo.results.length){
      // Prefer a result in Delhi, else in the given country, else first result
      const byDelhi = geo.results.find(r => /delhi/i.test(r.admin1 || ""));
      const byIN    = geo.results.find(r => (r.country_code || "").toUpperCase() === (countryCode || "IN").toUpperCase());
      const pick    = byDelhi || byIN || geo.results[0];

      return {
        latitude: pick.latitude,
        longitude: pick.longitude,
        label: [pick.name, pick.country].filter(Boolean).join(', ')
      };
    }
    throw new Error("No geocoding match");
  }

  async function initWeatherAndAQI(){
    try{
      const place = await resolveLocation(CITY_NAME, COUNTRY_CODE);
      document.getElementById('weatherCity').textContent = place.label;
      document.getElementById('aqiCity').textContent     = place.label;

      const wurl = `https://api.open-meteo.com/v1/forecast?latitude=${place.latitude}&longitude=${place.longitude}&current=temperature_2m,weather_code&hourly=temperature_2m,weather_code&timezone=auto`;
      const wdata = await fetch(wurl).then(r=>r.json());
      renderWeather(wdata);

      await fetchAQI(place.latitude, place.longitude);
    }catch(err){
      console.warn("Geocoding failed, using fallback coords:", err);
      document.getElementById('weatherCity').textContent = FALLBACK_COORDS.label;
      document.getElementById('aqiCity').textContent     = FALLBACK_COORDS.label;
      try{
        const wurl = `https://api.open-meteo.com/v1/forecast?latitude=${FALLBACK_COORDS.latitude}&longitude=${FALLBACK_COORDS.longitude}&current=temperature_2m,weather_code&hourly=temperature_2m,weather_code&timezone=auto`;
        const wdata = await fetch(wurl).then(r=>r.json());
        renderWeather(wdata);

        await fetchAQI(FALLBACK_COORDS.latitude, FALLBACK_COORDS.longitude);
      }catch(e){
        console.error(e);
        document.getElementById('weatherDesc').textContent = 'Weather unavailable';
      }
    }
  }

  function wxIcon(code){
    if(code===0) return '‚òÄÔ∏è';
    if([1,2].includes(code)) return 'üå§Ô∏è';
    if(code===3) return '‚òÅÔ∏è';
    if([45,48].includes(code)) return 'üå´Ô∏è';
    if([51,53,55,56,57].includes(code)) return 'üå¶Ô∏è';
    if([61,63,65].includes(code)) return 'üåßÔ∏è';
    if([66,67,71,73,75,77].includes(code)) return 'üå®Ô∏è';
    if([80,81,82].includes(code)) return 'üåßÔ∏è';
    if([95,96,99].includes(code)) return '‚õàÔ∏è';
    return '‚òÅÔ∏è';
  }
  function wxText(code){
    const map = {0:'Clear',1:'Mostly clear',2:'Partly cloudy',3:'Cloudy',45:'Fog',48:'Rime fog',51:'Drizzle',53:'Drizzle',55:'Drizzle',56:'Freezing drizzle',57:'Freezing drizzle',61:'Rain',63:'Rain',65:'Heavy rain',66:'Freezing rain',67:'Freezing rain',71:'Snow',73:'Snow',75:'Heavy snow',77:'Snow grains',80:'Showers',81:'Showers',82:'Heavy showers',95:'Thunderstorm',96:'Thunderstorm',99:'Thunderstorm'};
    return map[code] || '‚Äî';
  }
  function renderWeather(data){
    const cur = data.current;
    document.getElementById('weatherTemp').textContent = Math.round(cur.temperature_2m) + '¬∞';
    document.getElementById('weatherDesc').textContent = wxText(cur.weather_code);
    document.getElementById('weatherIcon').textContent = wxIcon(cur.weather_code);

    const fcEl = document.getElementById('weatherForecast');
    fcEl.innerHTML = '';
    const nowIdx = data.hourly.time.findIndex(t=> new Date(t).getTime() >= Date.now());
    for(let i=0;i<3;i++){
      const idx = Math.min(nowIdx + i, data.hourly.time.length-1);
      const t = new Date(data.hourly.time[idx]);
      const temp = Math.round(data.hourly.temperature_2m[idx]);
      const w = data.hourly.weather_code[idx];
      const div = document.createElement('div');
      div.className='forecast-item';
      div.innerHTML = `
        <span class="forecast-time">${String(t.getHours()).padStart(2,'0')}:00</span>
        <span class="wx">${wxIcon(w)}</span>
        <span class="forecast-temp">${temp}¬∞</span>`;
      fcEl.appendChild(div);
    }
  }

  // ===== AQI =====
  function aqiInfo(aqi){
    if (aqi == null || !isFinite(aqi)) return {label:'‚Äî', color:'rgba(255,255,255,0.12)', pos:0};
    if (aqi <= 50)   return {label:'Good',                  color:'#2ecc71', pos: (aqi/500)*100};
    if (aqi <= 100)  return {label:'Moderate',              color:'#f1c40f', pos: (aqi/500)*100};
    if (aqi <= 150)  return {label:'Unhealthy (Sensitive)', color:'#e67e22', pos: (aqi/500)*100};
    if (aqi <= 200)  return {label:'Unhealthy',             color:'#e74c3c', pos: (aqi/500)*100};
    if (aqi <= 300)  return {label:'Very Unhealthy',        color:'#9b59b6', pos: (aqi/500)*100};
    return            {label:'Hazardous',                   color:'#7f1d1d', pos: Math.min(100,(aqi/500)*100)};
  }

  async function fetchAQI(lat, lon){
    try{
      const url = `https://air-quality-api.open-meteo.com/v1/air-quality?latitude=${lat}&longitude=${lon}&current=us_aqi,pm2_5,pm10`;
      const data = await fetch(url).then(r=>r.json());
      const aqi  = data?.current?.us_aqi;
      const pm25 = data?.current?.pm2_5;
      const pm10 = data?.current?.pm10;

      const info = aqiInfo(aqi);
      document.getElementById('aqiBadge').style.borderColor = info.color;
      document.getElementById('aqiBadge').style.boxShadow   = `inset 0 0 0 1px ${info.color}22`;
      document.getElementById('aqiBadge').textContent       = `AQI ${Math.round(aqi)}`;
      document.getElementById('aqiValue').textContent       = Math.round(aqi);
      document.getElementById('aqiCat').textContent         = info.label;

      // pointer position along the color bar
      document.getElementById('aqiPointer').style.left = `${info.pos}%`;

      // tiny metrics
      document.getElementById('pm25').textContent = (pm25!=null)? `${Math.round(pm25)} ¬µg/m¬≥` : '‚Äî';
      document.getElementById('pm10').textContent = (pm10!=null)? `${Math.round(pm10)} ¬µg/m¬≥` : '‚Äî';
    }catch(e){
      console.warn('AQI fetch failed', e);
      document.getElementById('aqiBadge').textContent = 'AQI ‚Äî';
      document.getElementById('aqiCat').textContent   = 'Unavailable';
    }
  }
  </script>
</body>
</html>
